<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>WebAssembly Import Types · WasmtimeRuntime.jl</title><meta name="title" content="WebAssembly Import Types · WasmtimeRuntime.jl"/><meta property="og:title" content="WebAssembly Import Types · WasmtimeRuntime.jl"/><meta property="twitter:title" content="WebAssembly Import Types · WasmtimeRuntime.jl"/><meta name="description" content="Documentation for WasmtimeRuntime.jl."/><meta property="og:description" content="Documentation for WasmtimeRuntime.jl."/><meta property="twitter:description" content="Documentation for WasmtimeRuntime.jl."/><meta property="og:url" content="https://damourChris.github.io/WasmtimeRuntime.jl/56-imports/"/><meta property="twitter:url" content="https://damourChris.github.io/WasmtimeRuntime.jl/56-imports/"/><link rel="canonical" href="https://damourChris.github.io/WasmtimeRuntime.jl/56-imports/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">WasmtimeRuntime.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">WasmtimeRuntime</a></li><li><a class="tocitem" href="../01-getting-started/">Getting Started with WasmtimeRuntime.jl</a></li><li><a class="tocitem" href="../02-core-concepts/">Core Concepts</a></li><li><a class="tocitem" href="../10-configuration/">Configuration Guide</a></li><li><a class="tocitem" href="../20-values-and-types/">Values and Type System</a></li><li><a class="tocitem" href="../21-generic-vectors/">Generic Vector Wrapper (<code>WasmVec</code>)</a></li><li><a class="tocitem" href="../30-modules/">WebAssembly Modules</a></li><li><a class="tocitem" href="../40-instances/">WebAssembly Instances</a></li><li><a class="tocitem" href="../50-functions/">Function Calling and Type Conversion</a></li><li><a class="tocitem" href="../51-memory/">WebAssembly Memory</a></li><li><a class="tocitem" href="../52-tables/">WebAssembly Tables</a></li><li><a class="tocitem" href="../53-global/">WebAssembly Global Variables</a></li><li><a class="tocitem" href="../54-externs/">WebAssembly Externs</a></li><li><a class="tocitem" href="../55-exports/">WebAssembly Exports</a></li><li class="is-active"><a class="tocitem" href>WebAssembly Import Types</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Creating-Import-Types"><span>Creating Import Types</span></a></li><li><a class="tocitem" href="#Import-Type-Properties"><span>Import Type Properties</span></a></li><li><a class="tocitem" href="#Common-Use-Cases"><span>Common Use Cases</span></a></li><li><a class="tocitem" href="#Working-with-Function-Types"><span>Working with Function Types</span></a></li><li><a class="tocitem" href="#Error-Handling"><span>Error Handling</span></a></li><li><a class="tocitem" href="#Integration-Patterns"><span>Integration Patterns</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li><li><a class="tocitem" href="#Performance-Considerations"><span>Performance Considerations</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li><li><a class="tocitem" href="../60-objects/">WebAssembly Objects: Memory, Globals, and Tables</a></li><li><a class="tocitem" href="../70-error-handling/">Error Handling</a></li><li><a class="tocitem" href="../71-traps/">WebAssembly Traps</a></li><li><a class="tocitem" href="../80-performance/">Performance Guide</a></li><li><a class="tocitem" href="../81-conversions/">Conversion</a></li><li><a class="tocitem" href="../90-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../90-implementation-status/">Implementation Status</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li><li><a class="tocitem" href="../94-api-reference/">API Reference</a></li><li><a class="tocitem" href="../95-reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>WebAssembly Import Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>WebAssembly Import Types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/damourChris/WasmtimeRuntime.jl/blob/main/docs/src/56-imports.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="WebAssembly-Import-Types"><a class="docs-heading-anchor" href="#WebAssembly-Import-Types">WebAssembly Import Types</a><a id="WebAssembly-Import-Types-1"></a><a class="docs-heading-anchor-permalink" href="#WebAssembly-Import-Types" title="Permalink"></a></h1><p>The <code>WasmImportType</code> struct represents WebAssembly import declarations that specify external dependencies a module requires. This documentation covers creating, managing, and working with import type definitions.</p><p>!!! For now, only function imports are supported.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>WebAssembly imports allow modules to specify external functions, globals, memories, or tables they need from the host environment or other modules. The <code>WasmImportType</code> represents the type signature and naming information for these imports.</p><h2 id="Creating-Import-Types"><a class="docs-heading-anchor" href="#Creating-Import-Types">Creating Import Types</a><a id="Creating-Import-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Import-Types" title="Permalink"></a></h2><h3 id="From-String-Parameters"><a class="docs-heading-anchor" href="#From-String-Parameters">From String Parameters</a><a id="From-String-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#From-String-Parameters" title="Permalink"></a></h3><p>Create import types by specifying the module name, import name, and function signature:</p><pre><code class="language-julia hljs"># Create a function type first
params = [Int32, Float64]
results = [Int32]
functype = WasmFuncType(params, results)

# Create the import type
import_type = WasmImportType(&quot;math_module&quot;, &quot;add_numbers&quot;, functype)</code></pre><h3 id="From-Existing-Pointers"><a class="docs-heading-anchor" href="#From-Existing-Pointers">From Existing Pointers</a><a id="From-Existing-Pointers-1"></a><a class="docs-heading-anchor-permalink" href="#From-Existing-Pointers" title="Permalink"></a></h3><p>Reconstruct import types from C API pointers:</p><pre><code class="language-julia hljs"># From an existing import type pointer
ptr = some_existing_import_ptr
import_type = WasmImportType(ptr)

println(import_type.module_name)  # Extracted module name
println(import_type.import_name)  # Extracted import name</code></pre><h2 id="Import-Type-Properties"><a class="docs-heading-anchor" href="#Import-Type-Properties">Import Type Properties</a><a id="Import-Type-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Import-Type-Properties" title="Permalink"></a></h2><h3 id="Basic-Properties"><a class="docs-heading-anchor" href="#Basic-Properties">Basic Properties</a><a id="Basic-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Properties" title="Permalink"></a></h3><p>Access the core properties of an import type:</p><pre><code class="language-julia hljs">import_type = WasmImportType(&quot;env&quot;, &quot;print&quot;, functype)

# Access module and import names
@show import_type.module_name   # &quot;env&quot;
@show import_type.import_name   # &quot;print&quot;

# Check validity
@show isvalid(import_type)      # true

# Get import name (convenience function)
@show name(import_type)         # &quot;print&quot;</code></pre><h2 id="Common-Use-Cases"><a class="docs-heading-anchor" href="#Common-Use-Cases">Common Use Cases</a><a id="Common-Use-Cases-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Use-Cases" title="Permalink"></a></h2><h3 id="Module-Import-Declarations"><a class="docs-heading-anchor" href="#Module-Import-Declarations">Module Import Declarations</a><a id="Module-Import-Declarations-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Import-Declarations" title="Permalink"></a></h3><p>Define what a module needs from its environment:</p><pre><code class="language-julia hljs"># Print function: takes string, returns nothing
print_type = WasmFuncType([String], [])
print_import = WasmImportType(&quot;env&quot;, &quot;print&quot;, print_type)

# Math function: takes two numbers, returns one
add_type = WasmFuncType([Int32, Int32], [Int32])
add_import = WasmImportType(&quot;math&quot;, &quot;add&quot;, add_type)

# Memory import: (would use WasmMemoryType when available)
# memory_import = WasmImportType(&quot;env&quot;, &quot;memory&quot;, memory_type)</code></pre><h3 id="Import-Validation"><a class="docs-heading-anchor" href="#Import-Validation">Import Validation</a><a id="Import-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Import-Validation" title="Permalink"></a></h3><p>Validate import signatures before module instantiation:</p><pre><code class="language-julia hljs">function validate_import(import_type::WasmImportType)
    if !isvalid(import_type)
        return false, &quot;Invalid import type&quot;
    end

    if import_type.module_name == &quot;&quot;
        return false, &quot;Empty module name&quot;
    end

    if import_type.import_name == &quot;&quot;
        return false, &quot;Empty import name&quot;
    end

    return true, &quot;Valid&quot;
end

is_valid, message = validate_import(import_type)
println(&quot;Import validation: $message&quot;)</code></pre><h3 id="Import-Inspection"><a class="docs-heading-anchor" href="#Import-Inspection">Import Inspection</a><a id="Import-Inspection-1"></a><a class="docs-heading-anchor-permalink" href="#Import-Inspection" title="Permalink"></a></h3><p>Analyze module import requirements:</p><pre><code class="language-julia hljs">function analyze_import(import_type::WasmImportType)
    println(&quot;Import Analysis:&quot;)
    println(&quot;  Module: $(import_type.module_name)&quot;)
    println(&quot;  Name: $(import_type.import_name)&quot;)
    println(&quot;  Valid: $(isvalid(import_type))&quot;)

    # Could extract more type information here
    # when function type inspection is available
end

analyze_import(import_type)</code></pre><h2 id="Working-with-Function-Types"><a class="docs-heading-anchor" href="#Working-with-Function-Types">Working with Function Types</a><a id="Working-with-Function-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Function-Types" title="Permalink"></a></h2><h3 id="Simple-Function-Imports"><a class="docs-heading-anchor" href="#Simple-Function-Imports">Simple Function Imports</a><a id="Simple-Function-Imports-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Function-Imports" title="Permalink"></a></h3><p>Common patterns for function imports:</p><pre><code class="language-julia hljs"># No parameters, no return value (like print)
void_type = WasmFuncType([], [])
print_import = WasmImportType(&quot;console&quot;, &quot;log&quot;, void_type)

# One parameter, one return value
unary_type = WasmFuncType([Int32], [Int32])
abs_import = WasmImportType(&quot;math&quot;, &quot;abs&quot;, unary_type)

# Multiple parameters, one return value
binary_type = WasmFuncType([Int32, Int32], [Int32])
add_import = WasmImportType(&quot;math&quot;, &quot;add&quot;, binary_type)

# Multiple parameters, multiple return values
multi_type = WasmFuncType([Int32, Float64], [Int32, Float64])
complex_import = WasmImportType(&quot;utils&quot;, &quot;process&quot;, multi_type)</code></pre><h3 id="Type-Safety"><a class="docs-heading-anchor" href="#Type-Safety">Type Safety</a><a id="Type-Safety-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Safety" title="Permalink"></a></h3><p>Ensure type compatibility:</p><pre><code class="language-julia hljs">function create_safe_import(module_name, import_name, params, results)
    try
        functype = WasmFuncType(params, results)
        return WasmImportType(module_name, import_name, functype)
    catch e
        @error &quot;Failed to create import&quot; module=module_name name=import_name error=e
        return nothing
    end
end

# Usage
import_type = create_safe_import(&quot;env&quot;, &quot;func&quot;, [Int32], [Int32])
if import_type !== nothing
    println(&quot;Successfully created import&quot;)
end</code></pre><h2 id="Error-Handling"><a class="docs-heading-anchor" href="#Error-Handling">Error Handling</a><a id="Error-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Handling" title="Permalink"></a></h2><h3 id="Common-Error-Scenarios"><a class="docs-heading-anchor" href="#Common-Error-Scenarios">Common Error Scenarios</a><a id="Common-Error-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Error-Scenarios" title="Permalink"></a></h3><p>Handle various error conditions:</p><pre><code class="language-julia hljs"># Empty names
try
    WasmImportType(&quot;&quot;, &quot;function&quot;, functype)
catch ArgumentError as e
    println(&quot;Empty module name: $(e.msg)&quot;)
end

try
    WasmImportType(&quot;module&quot;, &quot;&quot;, functype)
catch ArgumentError as e
    println(&quot;Empty import name: $(e.msg)&quot;)
end

# Invalid pointers
try
    WasmImportType(Ptr{LibWasmtime.wasm_importtype_t}(C_NULL))
catch ArgumentError as e
    println(&quot;Null pointer: $(e.msg)&quot;)
end

# Invalid function type
invalid_functype = WasmFuncType([Int32], [Int32])
invalid_functype.ptr = C_NULL

try
    WasmImportType(&quot;module&quot;, &quot;function&quot;, invalid_functype)
catch e
    println(&quot;Invalid function type: $(e)&quot;)
end</code></pre><h3 id="Defensive-Programming"><a class="docs-heading-anchor" href="#Defensive-Programming">Defensive Programming</a><a id="Defensive-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#Defensive-Programming" title="Permalink"></a></h3><p>Build robust import handling:</p><pre><code class="language-julia hljs">function safe_import_creation(module_name, import_name, functype)
    # Validate inputs
    if isempty(module_name) || isempty(import_name)
        throw(ArgumentError(&quot;Module and import names cannot be empty&quot;))
    end

    if !isvalid(functype)
        throw(ArgumentError(&quot;Invalid function type&quot;))
    end

    # Create import
    try
        import_type = WasmImportType(module_name, import_name, functype)

        # Verify creation succeeded
        if !isvalid(import_type)
            throw(WasmtimeError(&quot;Failed to create valid import type&quot;))
        end

        return import_type
    catch e
        @error &quot;Import creation failed&quot; module=module_name name=import_name exception=e
        rethrow(e)
    end
end</code></pre><h2 id="Integration-Patterns"><a class="docs-heading-anchor" href="#Integration-Patterns">Integration Patterns</a><a id="Integration-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-Patterns" title="Permalink"></a></h2><h3 id="Module-Import-Lists"><a class="docs-heading-anchor" href="#Module-Import-Lists">Module Import Lists</a><a id="Module-Import-Lists-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Import-Lists" title="Permalink"></a></h3><p>Build complete import specifications:</p><pre><code class="language-julia hljs">function create_module_imports()
    imports = WasmImportType[]

    # Console functions
    log_type = WasmFuncType([String], [])
    push!(imports, WasmImportType(&quot;console&quot;, &quot;log&quot;, log_type))

    error_type = WasmFuncType([String], [])
    push!(imports, WasmImportType(&quot;console&quot;, &quot;error&quot;, error_type))

    # Math functions
    add_type = WasmFuncType([Int32, Int32], [Int32])
    push!(imports, WasmImportType(&quot;math&quot;, &quot;add&quot;, add_type))

    sqrt_type = WasmFuncType([Float64], [Float64])
    push!(imports, WasmImportType(&quot;math&quot;, &quot;sqrt&quot;, sqrt_type))

    return imports
end

module_imports = create_module_imports()
for imp in module_imports
    println(&quot;Import: $(imp.module_name).$(imp.import_name)&quot;)
end</code></pre><h3 id="Import-Resolution"><a class="docs-heading-anchor" href="#Import-Resolution">Import Resolution</a><a id="Import-Resolution-1"></a><a class="docs-heading-anchor-permalink" href="#Import-Resolution" title="Permalink"></a></h3><p>Match imports with available functions:</p><pre><code class="language-julia hljs">function resolve_imports(imports::Vector{WasmImportType}, available_modules)
    resolved = Dict()
    unresolved = WasmImportType[]

    for import_type in imports
        module_name = import_type.module_name
        import_name = import_type.import_name

        if haskey(available_modules, module_name) &amp;&amp;
           haskey(available_modules[module_name], import_name)
            resolved[import_name] = available_modules[module_name][import_name]
        else
            push!(unresolved, import_type)
        end
    end

    return resolved, unresolved
end</code></pre><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><h3 id="Naming-Conventions"><a class="docs-heading-anchor" href="#Naming-Conventions">Naming Conventions</a><a id="Naming-Conventions-1"></a><a class="docs-heading-anchor-permalink" href="#Naming-Conventions" title="Permalink"></a></h3><p>Follow consistent naming patterns:</p><pre><code class="language-julia hljs"># Use clear, descriptive names
good_import = WasmImportType(&quot;environment&quot;, &quot;print_string&quot;, functype)

# Avoid abbreviated or unclear names
# bad_import = WasmImportType(&quot;env&quot;, &quot;prt&quot;, functype)  # Unclear

# Use consistent module grouping
console_log = WasmImportType(&quot;console&quot;, &quot;log&quot;, log_type)
console_error = WasmImportType(&quot;console&quot;, &quot;error&quot;, error_type)
console_warn = WasmImportType(&quot;console&quot;, &quot;warn&quot;, warn_type)</code></pre><h3 id="Error-Messages"><a class="docs-heading-anchor" href="#Error-Messages">Error Messages</a><a id="Error-Messages-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Messages" title="Permalink"></a></h3><p>Provide actionable error information:</p><pre><code class="language-julia hljs">function validate_import_name(name::String, context::String)
    if isempty(name)
        throw(ArgumentError(&quot;$context name cannot be empty&quot;))
    end

    if length(name) &gt; 256
        throw(ArgumentError(&quot;$context name too long (max 256 characters): $name&quot;))
    end

    # Add other validation as needed
    return true
end

# Usage
validate_import_name(module_name, &quot;Module&quot;)
validate_import_name(import_name, &quot;Import&quot;)</code></pre><h3 id="Memory-Management"><a class="docs-heading-anchor" href="#Memory-Management">Memory Management</a><a id="Memory-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Management" title="Permalink"></a></h3><p>Handle resources properly:</p><pre><code class="language-julia hljs">function process_imports_safely(import_specs)
    imports = WasmImportType[]

    try
        for spec in import_specs
            functype = WasmFuncType(spec.params, spec.results)
            import_type = WasmImportType(spec.module, spec.name, functype)
            push!(imports, import_type)
        end

        # Process imports...
        return process_import_list(imports)

    catch e
        @error &quot;Failed to process imports&quot; exception=e
        # Cleanup handled by finalizers
        rethrow(e)
    end
end</code></pre><h2 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h2><h3 id="Batch-Operations"><a class="docs-heading-anchor" href="#Batch-Operations">Batch Operations</a><a id="Batch-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Operations" title="Permalink"></a></h3><p>Create imports efficiently:</p><pre><code class="language-julia hljs">function create_imports_batch(specifications)
    # Pre-allocate result vector
    imports = Vector{WasmImportType}(undef, length(specifications))

    for (i, spec) in enumerate(specifications)
        functype = WasmFuncType(spec.params, spec.results)
        imports[i] = WasmImportType(spec.module, spec.name, functype)
    end

    return imports
end</code></pre><h3 id="Reuse-Function-Types"><a class="docs-heading-anchor" href="#Reuse-Function-Types">Reuse Function Types</a><a id="Reuse-Function-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Reuse-Function-Types" title="Permalink"></a></h3><p>Avoid recreating identical function types:</p><pre><code class="language-julia hljs"># Cache common function types
const COMMON_FUNCTYPES = Dict(
    :void_void =&gt; WasmFuncType([], []),
    :i32_i32 =&gt; WasmFuncType([Int32], [Int32]),
    :i32_i32_i32 =&gt; WasmFuncType([Int32, Int32], [Int32]),
)

function create_import_with_cache(module_name, import_name, type_key)
    functype = COMMON_FUNCTYPES[type_key]
    return WasmImportType(module_name, import_name, functype)
end

# Usage
print_import = create_import_with_cache(&quot;console&quot;, &quot;log&quot;, :void_void)
add_import = create_import_with_cache(&quot;math&quot;, &quot;add&quot;, :i32_i32_i32)</code></pre><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><h3 id="Constructor-Methods"><a class="docs-heading-anchor" href="#Constructor-Methods">Constructor Methods</a><a id="Constructor-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-Methods" title="Permalink"></a></h3><pre><code class="language-julia hljs"># From string parameters
WasmImportType(module_name::String, import_name::String, functype::WasmFuncType)

# From C pointer
WasmImportType(ptr::Ptr{LibWasmtime.wasm_importtype_t})</code></pre><h3 id="Instance-Methods"><a class="docs-heading-anchor" href="#Instance-Methods">Instance Methods</a><a id="Instance-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Instance-Methods" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Check validity
isvalid(import_type::WasmImportType) -&gt; Bool

# Get import name
name(import_type::WasmImportType) -&gt; String

# Convert to C pointer
Base.unsafe_convert(::Type{Ptr{LibWasmtime.wasm_importtype_t}}, import_type) -&gt; Ptr

# Display information
Base.show(io::IO, import_type::WasmImportType)</code></pre><h3 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h3><pre><code class="language-julia hljs">import_type.ptr          # C API pointer
import_type.module_name  # Module name string
import_type.import_name  # Import name string</code></pre><hr/><p><strong>Note</strong>: Import types are fundamental to WebAssembly module linking and instantiation. Proper import type definition ensures modules can successfully resolve their external dependencies.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../55-exports/">« WebAssembly Exports</a><a class="docs-footer-nextpage" href="../60-objects/">WebAssembly Objects: Memory, Globals, and Tables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Monday 7 July 2025 20:55">Monday 7 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
